"""
模擬退火算法求解漢米頓路徑問題 - 科展優化版

特點：
1. 專為漢米頓路徑問題設計
2. 完整的效能計時與統計功能
3. 易於整合到C++/Python混合環境
4. 輸出格式符合科學實驗需求
5. 支援多種圖形結構
6. 可調整參數進行比較實驗

"""

import random
import math
import time
import statistics
import json
import csv
from typing import Dict, List, Tuple, Optional, Any
from enum import Enum
from dataclasses import dataclass

# 效能計時器
class Timer:
    """精確計時器"""
    def __init__(self):
        self.start_time = None
        self.elapsed_time = 0.0
        self.is_running = False
    
    def start(self):
        self.start_time = time.perf_counter()
        self.is_running = True
    
    def stop(self) -> float:
        if self.is_running and self.start_time is not None:
            self.elapsed_time = time.perf_counter() - self.start_time
            self.is_running = False
        return self.elapsed_time
    
    def get_elapsed(self) -> float:
        if self.is_running and self.start_time is not None:
            return time.perf_counter() - self.start_time
        return self.elapsed_time

@dataclass
class ExperimentResult:
    """實驗結果數據類"""
    algorithm_name: str
    graph_size: int
    success: bool
    execution_time: float
    iterations: int
    cost: float
    path_found: List[int]
    parameters: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """轉換為字典格式"""
        return {
            'algorithm': self.algorithm_name,
            'graph_size': self.graph_size,
            'success': self.success,
            'time_seconds': self.execution_time,
            'iterations': self.iterations,
            'cost': self.cost,
            'path_length': len(self.path_found),
            'parameters': self.parameters
        }

class GraphType(Enum):
    """圖形類型枚舉"""
    COMPLETE = "complete"
    GRID = "grid"
    RANDOM = "random"
    SPARSE = "sparse"

class HamiltonianSolver:
    """漢米頓路徑求解器基類"""
    
    def __init__(self, name: str):
        self.name = name
        self.timer = Timer()
        self.stats = {
            'total_runs': 0,
            'successful_runs': 0,
            'total_time': 0.0,
            'avg_time': 0.0,
            'min_time': float('inf'),
            'max_time': 0.0
        }
    
    def solve(self, graph, closed=True, **kwargs) -> Tuple[List[int], float, bool]:
        """求解方法（需在子類實現）"""
        raise NotImplementedError
    
    def record_run(self, success: bool, time_taken: float):
        """記錄運行結果"""
        self.stats['total_runs'] += 1
        self.stats['total_time'] += time_taken
        
        if success:
            self.stats['successful_runs'] += 1
        
        # 更新時間統計
        self.stats['min_time'] = min(self.stats['min_time'], time_taken)
        self.stats['max_time'] = max(self.stats['max_time'], time_taken)
        self.stats['avg_time'] = self.stats['total_time'] / self.stats['total_runs']
    
    def get_statistics(self) -> Dict[str, Any]:
        """獲取統計信息"""
        success_rate = 0.0
        if self.stats['total_runs'] > 0:
            success_rate = self.stats['successful_runs'] / self.stats['total_runs']
        
        return {
            **self.stats,
            'success_rate': success_rate,
            'name': self.name
        }

class SimulatedAnnealingSolver(HamiltonianSolver):
    """模擬退火算法求解器 - 科展優化版"""
    
    def __init__(self):
        super().__init__("Simulated_Annealing")
        # 默認參數
        self.default_params = {
            'initial_temp': 100.0,
            'cooling_rate': 0.995,
            'min_temp': 1e-8,
            'max_iterations': 20000,
            'max_no_improve': 3000,
            'use_restart': True,
            'restart_threshold': 1000,
            'neighbor_strategy': 'mixed'  # mixed, 2opt, swap, insertion
        }
    
    def _calculate_cost(self, path: List[int], graph: Dict[int, Dict[int, float]], 
                       closed: bool = True) -> float:
        """計算路徑成本（缺失邊的數量）"""
        cost = 0
        n = len(path)
        
        # 檢查是否包含所有節點
        if len(set(path)) != n:
            return float('inf')
        
        # 檢查邊是否存在
        for i in range(n - 1):
            a, b = path[i], path[i + 1]
            if b not in graph.get(a, {}):
                cost += 1  # 缺失一條邊
        
        # 如果是閉合路徑，檢查最後一個到第一個的邊
        if closed and n > 0:
            a, b = path[-1], path[0]
            if b not in graph.get(a, {}):
                cost += 1
        
        # 如果完全沒有缺失邊，返回0，否則返回缺失邊數量
        return cost
    
    def _is_valid_hamiltonian(self, path: List[int], graph: Dict[int, Dict[int, float]], 
                             closed: bool = True) -> bool:
        """檢查是否為有效漢米頓路徑"""
        return self._calculate_cost(path, graph, closed) == 0
    
    def _generate_initial_solution(self, nodes: List[int], 
                                  strategy: str = 'random') -> List[int]:
        """生成初始解"""
        if strategy == 'random':
            solution = nodes[:]
            random.shuffle(solution)
            return solution
        elif strategy == 'greedy':
            # 簡單貪心：從隨機節點開始，選擇度數最高的未訪問鄰居
            solution = []
            unvisited = set(nodes)
            
            # 隨機選擇起點
            current = random.choice(nodes)
            solution.append(current)
            unvisited.remove(current)
            
            while unvisited:
                # 獲取當前節點的鄰居
                neighbors = [n for n in unvisited if n in self.graph.get(current, {})]
                
                if not neighbors:
                    # 沒有可達鄰居，隨機選擇一個
                    next_node = random.choice(list(unvisited))
                else:
                    # 選擇度數最高的鄰居
                    next_node = max(neighbors, 
                                  key=lambda n: len(self.graph.get(n, {})))
                
                solution.append(next_node)
                unvisited.remove(next_node)
                current = next_node
            
            return solution
        else:
            # 默認隨機
            solution = nodes[:]
            random.shuffle(solution)
            return solution
    
    def _generate_neighbor(self, solution: List[int], strategy: str = 'mixed') -> List[int]:
        """生成鄰居解"""
        n = len(solution)
        
        if n < 2:
            return solution[:]
        
        # 根據策略選擇鄰域操作
        if strategy == 'mixed':
            # 混合策略：60% 2-opt, 40% swap
            operation = random.choices(['2opt', 'swap'], weights=[0.6, 0.4])[0]
        else:
            operation = strategy
        
        if operation == '2opt' and n >= 4:
            # 2-opt交換
            i = random.randint(0, n - 3)
            j = random.randint(i + 1, min(i + n // 2, n - 1))
            new_solution = solution[:i] + list(reversed(solution[i:j+1])) + solution[j+1:]
            return new_solution
        
        elif operation == 'swap':
            # 交換兩個節點
            i, j = random.sample(range(n), 2)
            new_solution = solution[:]
            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]
            return new_solution
        
        elif operation == 'insertion' and n >= 3:
            # 插入操作
            i = random.randint(0, n - 1)
            j = random.randint(0, n - 1)
            while i == j:
                j = random.randint(0, n - 1)
            
            node = solution.pop(i)
            if j > i:
                j -= 1
            solution.insert(j, node)
            return solution
        
        else:
            # 默認使用交換
            i, j = random.sample(range(n), 2)
            new_solution = solution[:]
            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]
            return new_solution
    
    def _acceptance_probability(self, old_cost: float, new_cost: float, 
                               temperature: float) -> float:
        """計算接受概率"""
        if new_cost < old_cost:
            return 1.0
        elif temperature > 0:
            return math.exp((old_cost - new_cost) / temperature)
        else:
            return 0.0
    
    def solve(self, graph: Dict[int, Dict[int, float]], 
              closed: bool = True, **kwargs) -> Tuple[List[int], float, bool]:
        """
        使用模擬退火算法求解漢米頓路徑
        
        參數:
            graph: 圖結構
            closed: 是否尋找閉合迴路
            **kwargs: 算法參數
            
        返回:
            (最佳路徑, 成本, 是否找到有效解)
        """
        # 開始計時
        self.timer.start()
        
        # 合併參數
        params = {**self.default_params, **kwargs}
        
        # 設置圖和節點
        self.graph = graph
        nodes = list(graph.keys())
        n_nodes = len(nodes)
        
        if n_nodes == 0:
            self.timer.stop()
            return [], 0.0, False
        
        # 生成初始解
        current_solution = self._generate_initial_solution(
            nodes, 
            params.get('initial_strategy', 'random')
        )
        current_cost = self._calculate_cost(current_solution, graph, closed)
        
        best_solution = current_solution[:]
        best_cost = current_cost
        
        # 算法參數
        temperature = params['initial_temp']
        cooling_rate = params['cooling_rate']
        min_temp = params['min_temp']
        max_iterations = params['max_iterations']
        max_no_improve = params['max_no_improve']
        use_restart = params['use_restart']
        restart_threshold = params['restart_threshold']
        neighbor_strategy = params['neighbor_strategy']
        
        # 追蹤變量
        iteration = 0
        no_improve_count = 0
        best_iteration = 0
        
        # 主循環
        while iteration < max_iterations and temperature > min_temp:
            # 生成鄰居解
            new_solution = self._generate_neighbor(current_solution, neighbor_strategy)
            new_cost = self._calculate_cost(new_solution, graph, closed)
            
            # 決定是否接受新解
            acceptance_prob = self._acceptance_probability(
                current_cost, new_cost, temperature
            )
            
            if random.random() < acceptance_prob:
                current_solution = new_solution
                current_cost = new_cost
                
                # 更新最佳解
                if current_cost < best_cost:
                    best_solution = current_solution[:]
                    best_cost = current_cost
                    best_iteration = iteration
                    no_improve_count = 0
                else:
                    no_improve_count += 1
            else:
                no_improve_count += 1
            
            # 降溫
            temperature *= cooling_rate
            
            # 重啟機制
            if use_restart and no_improve_count >= restart_threshold:
                # 對最佳解進行輕微擾動
                perturbed = best_solution[:]
                for _ in range(min(5, n_nodes // 4)):
                    perturbed = self._generate_neighbor(perturbed, 'swap')
                
                current_solution = perturbed
                current_cost = self._calculate_cost(current_solution, graph, closed)
                no_improve_count = 0
            
            # 檢查是否提前停止
            if no_improve_count >= max_no_improve:
                break
            
            iteration += 1
        
        # 停止計時
        execution_time = self.timer.stop()
        
        # 檢查是否找到有效解
        is_valid = self._is_valid_hamiltonian(best_solution, graph, closed)
        
        # 記錄運行結果
        self.record_run(is_valid, execution_time)
        
        return best_solution, best_cost, is_valid

# 圖形生成器
class GraphGenerator:
    """圖形生成器 - 用於創建測試圖形"""
    
    @staticmethod
    def generate_complete_graph(n: int, weight_range: Tuple[float, float] = (1.0, 10.0)):
        """生成完全圖"""
        graph = {i: {} for i in range(n)}
        
        for i in range(n):
            for j in range(i + 1, n):
                weight = random.uniform(*weight_range)
                graph[i][j] = weight
                graph[j][i] = weight
        
        return graph
    
    @staticmethod
    def generate_grid_graph(rows: int, cols: int):
        """生成網格圖"""
        n = rows * cols
        graph = {i: {} for i in range(n)}
        
        for r in range(rows):
            for c in range(cols):
                node = r * cols + c
                
                # 上下左右鄰居
                if r > 0:  # 上
                    neighbor = (r-1) * cols + c
                    graph[node][neighbor] = 1.0
                if r < rows-1:  # 下
                    neighbor = (r+1) * cols + c
                    graph[node][neighbor] = 1.0
                if c > 0:  # 左
                    neighbor = r * cols + (c-1)
                    graph[node][neighbor] = 1.0
                if c < cols-1:  # 右
                    neighbor = r * cols + (c+1)
                    graph[node][neighbor] = 1.0
        
        return graph
    
    @staticmethod
    def generate_random_graph(n: int, edge_probability: float = 0.5):
        """生成隨機圖"""
        graph = {i: {} for i in range(n)}
        
        for i in range(n):
            for j in range(i + 1, n):
                if random.random() < edge_probability:
                    weight = random.uniform(1.0, 10.0)
                    graph[i][j] = weight
                    graph[j][i] = weight
        
        return graph
    
    @staticmethod
    def generate_sparse_graph(n: int, max_degree: int = 3):
        """生成稀疏圖"""
        graph = {i: {} for i in range(n)}
        
        for i in range(n):
            # 確保每個節點至少有一個鄰居
            if len(graph[i]) == 0:
                j = random.randint(0, n-1)
                while j == i:
                    j = random.randint(0, n-1)
                graph[i][j] = 1.0
                graph[j][i] = 1.0
            
            # 隨機添加額外的邊，但限制度數
            for _ in range(max_degree - 1):
                if random.random() < 0.3 and len(graph[i]) < max_degree:
                    j = random.randint(0, n-1)
                    if j != i and j not in graph[i]:
                        graph[i][j] = 1.0
                        graph[j][i] = 1.0
        
        return graph

# 實驗管理器
class ExperimentManager:
    """實驗管理器 - 用於系統化比較不同算法"""
    
    def __init__(self):
        self.solvers = {}
        self.results = []
        self.experiment_config = {}
    
    def add_solver(self, name: str, solver: HamiltonianSolver):
        """添加求解器"""
        self.solvers[name] = solver
    
    def run_experiment(self, graph: Dict[int, Dict[int, float]], 
                       graph_type: str, graph_size: int, 
                       closed: bool = True, trials: int = 5):
        """運行實驗"""
        print(f"\n{'='*60}")
        print(f"實驗: {graph_type}圖 (大小: {graph_size})")
        print(f"運行次數: {trials}")
        print(f"{'='*60}")
        
        for solver_name, solver in self.solvers.items():
            print(f"\n求解器: {solver_name}")
            print("-" * 40)
            
            for trial in range(trials):
                # 運行求解器
                path, cost, success = solver.solve(graph, closed=closed)
                
                # 記錄結果
                result = ExperimentResult(
                    algorithm_name=solver_name,
                    graph_size=graph_size,
                    success=success,
                    execution_time=solver.timer.get_elapsed(),
                    iterations=0,  # 模擬退火會記錄迭代次數
                    cost=cost,
                    path_found=path,
                    parameters={}
                )
                
                self.results.append(result)
                
                print(f"  嘗試 {trial+1}: {'成功' if success else '失敗'}, "
                      f"時間: {solver.timer.get_elapsed():.4f}s, "
                      f"成本: {cost:.2f}")
    
    def export_results_csv(self, filename: str):
        """導出結果到CSV文件"""
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # 寫入標題
            writer.writerow([
                'algorithm', 'graph_size', 'success', 'time_seconds',
                'iterations', 'cost', 'path_length'
            ])
            
            # 寫入數據
            for result in self.results:
                data = result.to_dict()
                writer.writerow([
                    data['algorithm'],
                    data['graph_size'],
                    data['success'],
                    data['time_seconds'],
                    data['iterations'],
                    data['cost'],
                    data['path_length']
                ])
        
        print(f"\n結果已導出至: {filename}")
    
    def generate_report(self):
        """生成實驗報告"""
        report = []
        report.append("="*60)
        report.append("漢米頓路徑算法效能比較實驗報告")
        report.append("="*60)
        
        # 按算法分組結果
        by_algorithm = {}
        for result in self.results:
            algo = result.algorithm_name
            if algo not in by_algorithm:
                by_algorithm[algo] = []
            by_algorithm[algo].append(result)
        
        # 生成各算法統計
        for algo, results in by_algorithm.items():
            report.append(f"\n算法: {algo}")
            report.append("-" * 40)
            
            # 計算統計量
            success_count = sum(1 for r in results if r.success)
            total_trials = len(results)
            success_rate = success_count / total_trials if total_trials > 0 else 0
            
            times = [r.execution_time for r in results]
            avg_time = statistics.mean(times) if times else 0
